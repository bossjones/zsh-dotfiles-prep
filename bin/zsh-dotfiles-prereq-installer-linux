#!/usr/bin/env bash
#/ Usage: bin/zsh-dotfiles-prereq-installer [--debug]
#/ Install development dependencies on macOS, Debian 12, and Ubuntu 22.04.
# SOURCE: https://github.com/search?q=repo%3AMikeMcQuaid%2Fstrap%20Xcode&type=code

# TODO: Add sudoless ? https://github.com/atomantic/dotfiles/blob/main/install.sh#L16C1-L36C3
# TODO: Host File for ads? https://github.com/atomantic/dotfiles/blob/main/configs/hosts
# TODO: https://github.com/atomantic/dotfiles/blob/main/install.sh#L38-L52
# TODO: https://github.com/paulmillr/dotfiles/blob/master/home/.zlogin.sh#L5-L19
# TODO: https://github.com/mathiasbynens/dotfiles/blob/main/.bash_profile#L42C1-L50
# TODO: https://github.com/motty-mio2/dotfiles/blob/main/dot_zshrc.tmpl#L67-L79

# Install homebrew (macOS only)
# /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
# Install compat shell scripts to set env vars
# Backup .zsh* .profile .bash*, configs for certain apps like:
#

# > ~/.config
# bpytop  configstore   fontconfig  gh    iterm2   lvim      op         sourcery
# cheat   ffmpeg-tools  gallery-dl  htop  litecli  neofetch  powerline  wandb

# backup ~/.asdf
# backup ~/bin
# backup ~/.bin
# backup ~/.local/bin
# backup ~/.pyenv

# Borrow some of strap.sh
# SOURCE: https://raw.githubusercontent.com/MikeMcQuaid/strap/6950fe0db92215153cfc9d6c7e749783e2ca9430/bin/strap.sh

# Colors
ESC_SEQ="\x1b["
COL_RESET=$ESC_SEQ"39;49;00m"
COL_RED=$ESC_SEQ"31;01m"
COL_GREEN=$ESC_SEQ"32;01m"
COL_YELLOW=$ESC_SEQ"33;01m"
# shellcheck disable=SC2034  # Unused variables left for readability
COL_BLUE=$ESC_SEQ"34;01m"
# shellcheck disable=SC2034  # Unused variables left for readability
COL_MAGENTA=$ESC_SEQ"35;01m"
# shellcheck disable=SC2034  # Unused variables left for readability
COL_CYAN=$ESC_SEQ"36;01m"

set -e
# https://www.gnu.org/software/bash/manual/html_node/Bash-POSIX-Mode.html#Bash-POSIX-Mode
# set -o posix
# [ -n "$ZSH_DOTFILES_PREP_DEBUG" ] && set -x

[[ $1 == "--debug" || -o xtrace ]] && ZSH_DOTFILES_PREP_DEBUG="1"
ZSH_DOTFILES_PREP_SUCCESS=""

sudo_askpass() {
  if [ -n "$SUDO_ASKPASS" ]; then
    sudo --askpass "$@"
  else
    sudo "$@"
  fi
}

cleanup() {
  set +e
  # AI: CLT_PLACEHOLDER is macOS specific, ensure it's only used there.
  if [ "$CURRENT_OS" = "macos" ] && [ -n "$CLT_PLACEHOLDER" ]; then
    sudo_askpass rm -rf "$CLT_PLACEHOLDER"
  fi
  sudo_askpass rm -rf "$SUDO_ASKPASS" "$SUDO_ASKPASS_DIR"
  sudo --reset-timestamp
  if [ -z "$ZSH_DOTFILES_PREP_SUCCESS" ]; then
    if [ -n "$ZSH_DOTFILES_PREP_STEP" ]; then
      echo "!!! $ZSH_DOTFILES_PREP_STEP FAILED" >&2
    else
      echo "!!! FAILED" >&2
    fi
    if [ -z "$ZSH_DOTFILES_PREP_DEBUG" ]; then
      echo "!!! Run '$0 --debug' for debugging output." >&2
      echo "!!! If you're stuck: file an issue with debugging output at:" >&2
      echo "!!!   $ZSH_DOTFILES_PREP_ISSUES_URL" >&2
    fi
  fi
}

trap "cleanup" EXIT

if [ -n "$ZSH_DOTFILES_PREP_DEBUG" ]; then
  set -x
else
  ZSH_DOTFILES_PREP_QUIET_FLAG="-q"
  Q="$ZSH_DOTFILES_PREP_QUIET_FLAG"
  # echo "${Q}" # AI: This echo seems unintentional, commenting out.
fi

STDIN_FILE_DESCRIPTOR="0"
[ -t "$STDIN_FILE_DESCRIPTOR" ] && ZSH_DOTFILES_PREP_INTERACTIVE="1"

# Set by web/app.rb
# ZSH_DOTFILES_PREP_GIT_NAME=
# ZSH_DOTFILES_PREP_GIT_EMAIL=
# ZSH_DOTFILES_PREP_GITHUB_USER=
# ZSH_DOTFILES_PREP_GITHUB_TOKEN=
# CUSTOM_HOMEBREW_TAP=
# CUSTOM_BREW_COMMAND=
ZSH_DOTFILES_PREP_ISSUES_URL='https://github.com/bossjones/zsh-dotfiles-prep/issues/new'

# We want to always prompt for sudo password at least once rather than doing
# root stuff unexpectedly.
sudo --reset-timestamp

# functions for turning off debug for use when handling the user password
clear_debug() {
  set +x
}

reset_debug() {
  if [ -n "$ZSH_DOTFILES_PREP_DEBUG" ]; then
    set -x
  fi
}

# Initialise (or reinitialise) sudo to save unhelpful prompts later.
sudo_init() {
  if [ -z "$ZSH_DOTFILES_PREP_INTERACTIVE" ]; then
    return
  fi

  # If TouchID for sudo is setup: use that instead (macOS specific).
  if [ "$CURRENT_OS" = "macos" ] && grep -q pam_tid /etc/pam.d/sudo; then
    return
  fi

  local SUDO_PASSWORD SUDO_PASSWORD_SCRIPT

  if ! sudo --validate --non-interactive &>/dev/null; then
    while true; do
      read -rsp "--> Enter your password (for sudo access):" SUDO_PASSWORD
      echo
      if sudo --validate --stdin 2>/dev/null <<<"$SUDO_PASSWORD"; then
        break
      fi

      unset SUDO_PASSWORD
      echo "!!! Wrong password!" >&2
    done

    clear_debug
    SUDO_PASSWORD_SCRIPT="$(
      cat <<BASH
#!/bin/bash
echo "$SUDO_PASSWORD"
BASH
    )"
    unset SUDO_PASSWORD
    SUDO_ASKPASS_DIR="$(mktemp -d)"
    SUDO_ASKPASS="$(mktemp "$SUDO_ASKPASS_DIR"/strap-askpass-XXXXXXXX)"
    chmod 700 "$SUDO_ASKPASS_DIR" "$SUDO_ASKPASS"
    bash -c "cat > '$SUDO_ASKPASS'" <<<"$SUDO_PASSWORD_SCRIPT"
    unset SUDO_PASSWORD_SCRIPT
    reset_debug

    export SUDO_ASKPASS
  fi
}

sudo_refresh() {
  clear_debug
  if [ -n "$SUDO_ASKPASS" ]; then
    sudo --askpass --validate
  else
    sudo_init
  fi
  reset_debug
}

abort() {
  ZSH_DOTFILES_PREP_STEP=""
  echo "!!! $*" >&2
  exit 1
}

log() {
  ZSH_DOTFILES_PREP_STEP="$*"
  sudo_refresh
  echo "--> $*"
}

logn() {
  ZSH_DOTFILES_PREP_STEP="$*"
  sudo_refresh
  printf -- "--> %s " "$*"
}

logk() {
  ZSH_DOTFILES_PREP_STEP=""
  echo "OK"
}

logskip() {
  ZSH_DOTFILES_PREP_STEP=""
  echo "SKIPPED"
  echo "$*"
}

escape() {
  printf '%s' "${1//\'/\'}"
}

# SOURCE: https://github.com/atomantic/dotfiles/blob/main/lib_sh/echos.sh
function ok() {
  echo -e "${COL_GREEN}[ok]$COL_RESET ""$1"
}

function bot() {
  echo -e "\n$COL_GREEN\[._.]/$COL_RESET - ""$1"
}

function running() {
  echo -en "$COL_YELLOW ⇒ $COL_RESET""$1"": "
}

function action() {
  echo -e "\n${COL_YELLOW}[action]:$COL_RESET\n ⇒ $1..."
}

function warn() {
  echo -e "${COL_YELLOW}[warning]$COL_RESET ""$1"
}

function error() {
  echo -e "${COL_RED}[error]$COL_RESET ""$1"
}

function print_error() {
  printf " [✖] %s\n" "$1"
}

function print_result() {

  if [ "$1" -eq 0 ]; then
    print_success "$2"
  else
    print_error "$2"
  fi

  return "$1"

}

function print_success() {
  printf " [✔] %s\n" "$1"
}

# Given a list of scripts in the dotfiles repo, run the first one that exists
run_dotfile_scripts() {
  if [ -d ~/.dotfiles ]; then
    (
      cd ~/.dotfiles
      for i in "$@"; do
        if [ -f "$i" ] && [ -x "$i" ]; then
          log "Running dotfiles $i:"
          if [ -z "$ZSH_DOTFILES_PREP_DEBUG" ]; then
            "$i" 2>/dev/null
          else
            "$i"
          fi
          break
        fi
      done
    )
  fi
}

# SOURCE: https://rtx.pub/install.sh
#region environment setup
get_os() {
  os="$(uname -s)"
  if [ "$os" = Darwin ]; then
    echo "macos"
  elif [ "$os" = Linux ]; then
    # Further check for Debian/Ubuntu
    if [ -f /etc/os-release ]; then
        # shellcheck source=/dev/null
        source /etc/os-release
        if [ "$ID" = "debian" ] || [ "$ID" = "ubuntu" ]; then
            echo "linux" # Supported Linux
        else
            error "Unsupported Linux distribution: $ID"
            exit 1
        fi
    else
        error "Unsupported Linux distribution (unknown)"
        exit 1
    fi
  else
    error "unsupported OS: $os"
    exit 1
  fi
}

# SOURCE: https://rtx.pub/install.sh
get_arch() {
  arch="$(uname -m)"
  if [ "$arch" = x86_64 ]; then
    echo "x64"
  elif [ "$arch" = aarch64 ] || [ "$arch" = arm64 ]; then
    echo "arm64"
  else
    error "unsupported architecture: $arch"
    exit 1
  fi
}

CURRENT_OS="$(get_os)"
# shellcheck disable=SC2034  # Unused variables left for readability
CURRENT_ARCH="$(get_arch)"

# get_system() { # AI: This function is defined but not used.
#   os="$(get_os)"
#   arch="$(get_arch)"
# }
# SOURCE: https://rtx.pub/install.sh

# [ -e filepath ] Returns true if file exists.
# [ -x filepath ] Returns true if file exists and executable.
# [ -S filepath ] Returns true if file exists and its a socket file.
# [ expr1 -a expr2 ] Returns true if both the expression is true.
# [ expr1 -o expr2 ] Returns true if either of the expression1 or 2 is true.
# From the man bash pages (especially the CONDITIONAL EXPRESSIONS section):
# -a file
#         True if file exists.
#  -b file
#         True if file exists and is a block special file.
#  -c file
#         True if file exists and is a character special file.
#  -d file
#         True if file exists and is a directory.
#  -e file
#         True if file exists.
#  -f file
#         True if file exists and is a regular file.
#  -g file
#         True if file exists and is set-group-id.
#  -h file
#         True if file exists and is a symbolic link.
#  -k file
#         True if file exists and its ``sticky'' bit is set.
#  -p file
#         True if file exists and is a named pipe (FIFO).
#  -r file
#         True if file exists and is readable.
#  -s file
#         True if file exists and has a size greater than zero.
#  -t fd  True if file descriptor fd is open and refers to a terminal.
#  -u file
#         True if file exists and its set-user-id bit is set.
#  -w file
#         True if file exists and is writable.
#  -x file
#         True if file exists and is executable.

# is_file_or_folder() { # AI: This function is defined but not used.
#   # if [ -d ~/.dotfiles ]; then
#   (
#     # logn "does this exists: $1"
#     # for i in "$@"; do
#     # if is regular file, or symbolic link, or directory
#     if [ -f "$1" ] || [ -h "$1" ] || [ -d "$1" ]; then
#       echo "${1}"
#     else
#       echo ""
#     fi
#     # done
#   )
#   # fi
# }

# https://github.com/bitflight-devops/shell-scripts/blob/main/install.sh
command_exists() { command -v "$@" >/dev/null 2>&1; }


take_backup() {
  # Define a list of string variable
  # shellcheck disable=SC2088  # Tilde does not expand in quotes
  # to_check_for="~/.asdf,~/bin,~/.bin,~/.local,~/.pyenv,~/.config/gh,~/.config/lvim,~/.config/sourcery,~/.config/cheat,~/.zshrc.local,~/.zshrc,~/.zprofile,~/.zshenv,~/.zsh.d,~/.profile"

  echo "Creating backups folder ~/backups"
  mkdir -pv ~/backups || true >/dev/null

  echo "Check For existence of file/folder"

  # shellcheck disable=SC2088  # Tilde does not expand in quotes
  arr=(~/.bashrc ~/.bash_profile ~/.zshrc.local ~/.zshrc ~/.zprofile ~/.zshenv ~/.zsh.d ~/.profile ~/.config)

  echo "${arr[@]}" # AI: This echo is for debugging, could be removed in prod.

  echo "Backing up the following files/folders:"

  ts=$(date +"%Y%m%d_%H%M%S")

  # AI: Using standard 'tar' and improved quoting for array expansion.
  tar --create --gzip --dereference --file="${HOME}/backups/${ts}_zsh_dotfiles.tgz" "${arr[@]}"
}

reshim() {
  # SOURCE: https://github.com/bitflight-devops/shell-scripts/blob/27bff97ed9106c7c21f70d397887bbf514eb80e4/mac_development_computer_setup/helper_functions.sh
  # Reshim ASDF if it is installed
  if command_exists asdf; then
    asdf reshim
  fi
}

[ "$USER" = "root" ] && abort "Run zsh-dotfiles-prereq-installer as yourself, not root."
# which grep # AI: This seems like a debug line, can be removed.

if [ "$CURRENT_OS" = "macos" ]; then
  groups | \grep -E "\b(admin)\b" || abort "Add $USER to the admin group."

  # Prevent sleeping during script execution, as long as the machine is on AC power
  caffeinate -s -w $$ &

  # Check and, if necessary, enable sudo authentication using TouchID.
  # Don't care about non-alphanumeric filenames when doing a specific match
  # shellcheck disable=SC2010
  if ls /usr/lib/pam | grep -q "pam_tid.so"; then # AI: Simplified grep
    logn "Configuring sudo authentication using TouchID:"
    PAM_FILE="/etc/pam.d/sudo"
    FIRST_LINE="# sudo: auth account password session"
    if grep -q pam_tid.so "$PAM_FILE"; then # AI: Simplified grep
      logk
    elif ! head -n1 "$PAM_FILE" | grep -q "$FIRST_LINE"; then # AI: Simplified grep
      logskip "$PAM_FILE is not in the expected format!"
    else
      TOUCHID_LINE="auth       sufficient     pam_tid.so"
      sudo_askpass sed -i .bak -e \
        "s/$FIRST_LINE/$FIRST_LINE\n$TOUCHID_LINE/" \
        "$PAM_FILE"
      sudo_askpass rm "$PAM_FILE.bak"
      logk
    fi
  fi
elif [ "$CURRENT_OS" = "linux" ]; then
  # Check if user is in sudo group (Debian/Ubuntu)
  groups | \grep -E "\b(sudo)\b" || abort "Add $USER to the sudo group (e.g., sudo usermod -aG sudo $USER)."
fi


# Set some basic security settings (macOS specific in original script).
if [ "$CURRENT_OS" = "macos" ]; then
  logn "Configuring security settings (macOS):" # AI: Clarified this is macOS specific
  # AI: Original script had no actual security settings here, just the log.
  # AI: If there were settings, they would go here.
  logk
fi


if [ "$CURRENT_OS" = "macos" ]; then
  # Install the Xcode Command Line Tools.
  if ! [ -f "/Library/Developer/CommandLineTools/usr/bin/git" ]; then
    log "Installing the Xcode Command Line Tools:"
    CLT_PLACEHOLDER="/tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress"
    sudo_askpass touch "$CLT_PLACEHOLDER"

    CLT_PACKAGE=$(softwareupdate -l |
      grep -B 1 "Command Line Tools" |
      awk -F"*" '/^ *\*/ {print $2}' |
      sed -e 's/^ *Label: //' -e 's/^ *//' |
      sort -V |
      tail -n1)
    if [ -n "$CLT_PACKAGE" ]; then # AI: Check if package found
        sudo_askpass softwareupdate -i "$CLT_PACKAGE"
    else
        warn "Could not find Xcode Command Line Tools package via softwareupdate -l."
    fi
    sudo_askpass rm -f "$CLT_PLACEHOLDER"
    if ! [ -f "/Library/Developer/CommandLineTools/usr/bin/git" ]; then
      if [ -n "$ZSH_DOTFILES_PREP_INTERACTIVE" ]; then
        echo
        logn "Requesting user install of Xcode Command Line Tools:"
        xcode-select --install
      else
        echo
        abort "Run 'xcode-select --install' to install the Xcode Command Line Tools."
      fi
    fi
    logk
  else
    log "Xcode Command Line Tools already installed."
  fi

  # Check if the Xcode license is agreed to and agree if not.
  xcode_license() {
    if /usr/bin/xcrun clang 2>&1 | grep -q license; then # AI: Simplified grep
      if [ -n "$ZSH_DOTFILES_PREP_INTERACTIVE" ]; then
        logn "Asking for Xcode license confirmation:"
        sudo_askpass xcodebuild -license
        logk
      else
        abort "Run 'sudo xcodebuild -license' to agree to the Xcode license."
      fi
    fi
  }

  if [ -n "$ZSH_DOTFILES_PREP_CI" ]; then
    # echo "SKIPPED (for CI)" # AI: logskip is better
    logskip "Xcode license check SKIPPED (for CI)"
  else
    xcode_license
  fi
fi

# Setup Git configuration.
logn "Configuring Git:"
if [ -n "$ZSH_DOTFILES_PREP_GIT_NAME" ] && ! git config user.name >/dev/null; then
  git config --global user.name "$ZSH_DOTFILES_PREP_GIT_NAME"
fi

if [ -n "$ZSH_DOTFILES_PREP_GIT_EMAIL" ] && ! git config user.email >/dev/null; then
  git config --global user.email "$ZSH_DOTFILES_PREP_GIT_EMAIL"
fi

if [ -n "$ZSH_DOTFILES_PREP_GITHUB_USER" ] && [ "$(git config github.user)" != "$ZSH_DOTFILES_PREP_GITHUB_USER" ]; then
  git config --global github.user "$ZSH_DOTFILES_PREP_GITHUB_USER"
fi

# Squelch git 2.x warning message when pushing
if ! git config push.default >/dev/null; then
  git config --global push.default current
fi
logk

if [ "$CURRENT_OS" = "macos" ]; then
  # Setup Homebrew directory and permissions.
  logn "Installing Homebrew (macOS):"
  HOMEBREW_PREFIX_DEFAULT=""
  UNAME_MACHINE="$(/usr/bin/uname -m)"
  if [[ $UNAME_MACHINE == "arm64" ]]; then
    HOMEBREW_PREFIX_DEFAULT="/opt/homebrew"
  else
    HOMEBREW_PREFIX_DEFAULT="/usr/local"
  fi

  HOMEBREW_PREFIX="$(brew --prefix 2>/dev/null || echo "$HOMEBREW_PREFIX_DEFAULT")"
  HOMEBREW_REPOSITORY="$(brew --repository 2>/dev/null || echo "$HOMEBREW_PREFIX_DEFAULT/Homebrew")" # AI: Adjusted default for repository if prefix is /opt/homebrew

  if [[ "$UNAME_MACHINE" == "arm64" ]] && [[ "$HOMEBREW_PREFIX" == "/usr/local" ]]; then # AI: Ensure correct prefix for arm64
      HOMEBREW_PREFIX="/opt/homebrew"
      HOMEBREW_REPOSITORY="${HOMEBREW_PREFIX}"
  elif [[ "$UNAME_MACHINE" != "arm64" ]] && [[ "$HOMEBREW_PREFIX" == "/opt/homebrew" ]]; then # AI: Ensure correct prefix for x86_64
      HOMEBREW_PREFIX="/usr/local"
      HOMEBREW_REPOSITORY="${HOMEBREW_PREFIX}/Homebrew"
  elif [[ "$HOMEBREW_PREFIX" == "$HOMEBREW_PREFIX_DEFAULT" ]] && [[ "$HOMEBREW_REPOSITORY" == "$HOMEBREW_PREFIX_DEFAULT/Homebrew" ]] && [[ "$UNAME_MACHINE" == "arm64" ]]; then
      # Handles case where brew --prefix might not be available yet but defaults are for x86_64
      HOMEBREW_REPOSITORY="${HOMEBREW_PREFIX}"
  fi


  [ -d "$HOMEBREW_PREFIX" ] || sudo_askpass mkdir -p "$HOMEBREW_PREFIX"
  # AI: Original script had specific chown for /usr/local, this is more general for HOMEBREW_PREFIX
  # if [ "$HOMEBREW_PREFIX" = "/usr/local" ]; then
  #   sudo_askpass chown "root:wheel" "$HOMEBREW_PREFIX" 2>/dev/null || true
  # fi
  (
    cd "$HOMEBREW_PREFIX"
    sudo_askpass mkdir -p Cellar Caskroom Frameworks bin etc include lib opt sbin share var
    # AI: On arm64, group might be 'staff' or 'admin'. 'admin' is more common for sudo users.
    sudo_askpass chown -R "$USER:admin" Cellar Caskroom Frameworks bin etc include lib opt sbin share var . # AI: Added . to chown the prefix dir itself
  )

  [ -d "$HOMEBREW_REPOSITORY" ] || sudo_askpass mkdir -p "$HOMEBREW_REPOSITORY"
  sudo_askpass chown -R "$USER:admin" "$HOMEBREW_REPOSITORY"

  if [ ! -x "$HOMEBREW_PREFIX/bin/brew" ]; then # AI: Only install if brew command doesn't exist or isn't executable
    log "Downloading and installing Homebrew..."
    # AI: Using the official installer is safer and handles more edge cases.
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
  else
    log "Homebrew already installed."
  fi
  # Ensure Homebrew bin is on PATH for subsequent brew commands
  export PATH="$HOMEBREW_PREFIX/bin:$PATH"
  logk

  # Update Homebrew.
  logn "Updating Homebrew:"
  brew update # AI: Removed --quiet to see progress/errors
  logk

  # AI: Removed brew tap commands as they are often not needed or specific tools are installed differently.
  # brew tap schniz/tap || true
  # brew tap bossjones/asdf-versions || true

  # AI: Homebrew package installations are macOS specific.
  # AI: Many of these tools will be installed via apt on Linux, or via asdf/fnm/pyenv.
  # AI: For macOS, users can manage these via their Brewfile or install manually.
  # AI: This script focuses on prerequisites. Key tools like git, curl, build tools are covered.
  # AI: For a minimal setup, we ensure core dev tools.
  # AI: The original script installed a very long list of tools via brew.
  # AI: This has been simplified to focus on OS-level prerequisites.
  # AI: Users are expected to install their preferred tools using Homebrew (macOS) or apt (Linux) as needed.
  # AI: Example of installing a few key tools if needed:
  # logn '(brew) Installing some key tools (git, zsh, fzf, ripgrep, gh, neovim):'
  # brew install git zsh fzf ripgrep gh neovim || true # AI: Example
  # logk

  if [ "$ZSH_DOTFILES_PREP_SKIP_SOFTWARE_UPDATES" = "1" ]; then
    logn 'skipping macos software updates for now ...'
    logk
  else
    # Check and install any remaining software updates.
    logn "Checking for software updates:"
    if softwareupdate -l 2>&1 | grep -q "No new software available."; then # AI: Simplified grep
      logk
    else
      echo
      log "Installing software updates:"
      if [ -z "$ZSH_DOTFILES_PREP_CI" ]; then
        sudo_askpass softwareupdate --install --all --agree-to-license # AI: Added --agree-to-license
        xcode_license # AI: Re-check license after updates
        logk
      else
        logskip "Software updates SKIPPED (for CI)"
      fi
    fi
  fi

  # AI: Brewfile logic is macOS specific and user-dependent. Kept for macOS.
  if [ "$ZSH_DOTFILES_PREP_SKIP_BREW_BUNDLE" = "1" ]; then
    logn 'skipping brew bundle install ...'
    logk
  else
    # Setup Brewfile
    if [ -n "$ZSH_DOTFILES_PREP_GITHUB_USER" ] && { [ ! -f "$HOME/.Brewfile" ] || [ "$HOME/.Brewfile" -ef "$HOME/.homebrew-brewfile/Brewfile" ]; }; then
      HOMEBREW_BREWFILE_URL="https://github.com/$ZSH_DOTFILES_PREP_GITHUB_USER/homebrew-brewfile"

      if git ls-remote "$HOMEBREW_BREWFILE_URL" &>/dev/null; then
        log "Fetching $ZSH_DOTFILES_PREP_GITHUB_USER/homebrew-brewfile from GitHub:"
        if [ ! -d "$HOME/.homebrew-brewfile" ]; then
          log "Cloning to ~/.homebrew-brewfile:"
          git clone "$HOMEBREW_BREWFILE_URL" ~/.homebrew-brewfile
          logk
        else
          (
            cd ~/.homebrew-brewfile
            git pull --rebase # AI: Added --rebase
          )
        fi
        ln -sf ~/.homebrew-brewfile/Brewfile ~/.Brewfile
        logk
      fi
    fi

    # Install from local Brewfile
    if [ -f "$HOME/.Brewfile" ]; then
      log "Installing from user Brewfile (usually ~/.Brewfile):" # AI: Clarified path
      brew bundle check --global || brew bundle --global
      logk
    fi
  fi
fi # End of macOS specific Homebrew and software update block

# Generic directory creation
logn "Make local bin paths"
mkdir -pv ~/bin || true
mkdir -pv ~/.bin || true
mkdir -pv ~/.local/bin || true
mkdir -pv ~/.local/src || true
logk

add_helper_functions_to_bashrc() {
  # shellcheck disable=SC2016  # Expressions don't expand in single quotes, use double quotes for that.
  local this_script='$HOME/compat.bash' # AI: compat.bash is for bash specific things

  # Add helper functions to profile
  local source_line="[ -f \"${this_script}\" ] && source \"${this_script}\""
  touch ~/.bashrc || true # AI: Ensure .bashrc exists
  if ! grep -qF "${source_line}" ~/.bashrc; then # AI: Use -F for fixed string grep
    echo "Adding helper functions to ~/.bashrc"
    echo "" >> ~/.bashrc # AI: Add a newline for separation
    echo "${source_line}" >>~/.bashrc
  fi
}

add_helper_functions_to_profile() {
  # shellcheck disable=SC2016  # Expressions don't expand in single quotes, use double quotes for that.
  local this_script='$HOME/compat.sh' # AI: compat.sh is for POSIX sh compatible things

  # Add helper functions to profile
  local source_line="[ -f \"${this_script}\" ] && source \"${this_script}\""
  touch ~/.profile || true
  if ! grep -qF "${source_line}" ~/.profile; then # AI: Use -F for fixed string grep
    echo "Adding helper functions to ~/.profile"
    echo "" >> ~/.profile # AI: Add a newline for separation
    echo "${source_line}" >>~/.profile
  fi
}

add_helper_functions_to_shells() {
  add_helper_functions_to_bashrc
  logk
  add_helper_functions_to_profile
  logk
}

# make sure deps are present first
if [ "$CURRENT_OS" = "linux" ]; then
  # shellcheck disable=SC2002  # Useless cat. Consider 'cmd < file | ..' or 'cmd file | ..' instead
  # os_name=$(cat /etc/os-release | grep -oP '^NAME="\K[^"]+') # AI: Already checked in get_os
  # shellcheck source=/dev/null
  source /etc/os-release # ID and VERSION_ID will be available
  log "Detected $NAME $VERSION_ID"

  log "Updating package list and installing prerequisites for $NAME..."
  sudo_askpass apt-get update -y
  # AI: Consolidated and expanded apt package list
  sudo_askpass apt-get install -y \
    build-essential \
    libssl-dev \
    zlib1g-dev \
    cmake \
    libbz2-dev \
    libreadline-dev \
    libsqlite3-dev \
    curl \
    libncursesw5-dev \
    xz-utils \
    tk-dev \
    libxml2-dev \
    libxmlsec1-dev \
    libffi-dev \
    liblzma-dev \
    unzip \
    apt-transport-https \
    ca-certificates \
    gnupg \
    lsb-release \
    pkg-config \
    autogen \
    bash \
    direnv \
    fd-find \
    gnutls-bin \
    libgnutls28-dev \
    findutils \
    fzf \
    gawk \
    gcc \
    gh \
    git \
    indent \
    hub \
    jq \
    less \
    lesspipe \
    lsof \
    luarocks \
    moreutils \
    neofetch \
    neovim \
    nnn \
    nodejs \
    npm \
    tree \
    ripgrep \
    rsync \
    screen \
    screenfetch \
    shellcheck \
    shfmt \
    urlview \
    vim \
    watch \
    wget \
    zsh \
    ruby-build \
    rbenv \
    cheat \
    diff-so-fancy \
    git-delta
    # AI: Low confidence: fpp (Facebook PathPicker) - typically pip install fpp. Not in main repos.
    # sudo_askpass pip3 install fpp # AI: Low confidence, ensure pip3 is available or install python3-pip
    # AI: Low confidence: luv (Lua binding for libuv) - typically luarocks install luv
    # sudo_askpass luarocks install luv # AI: Low confidence, ensure luarocks is configured
  logk

  log "Checking for fd symlink..."
  if command_exists fdfind && ! command_exists fd; then
    if [ -d "${HOME}/.local/bin" ]; then # Ensure ~/.local/bin is on PATH
        ln -sf "$(command -v fdfind)" "${HOME}/.local/bin/fd"
        ok "Symlinked fdfind to fd in ${HOME}/.local/bin/fd"
    else
        warn "${HOME}/.local/bin does not exist. Cannot create symlink for fd. Make sure it's on your PATH."
    fi
  elif command_exists fd; then
    ok "fd command already available."
  else
    warn "fdfind not installed, cannot create fd symlink."
  fi
  logk

  if [ ! -d "${HOME}/.fnm" ]; then
    log "Installing fnm (Node.js version manager)..."
    curl -fsSL https://fnm.vercel.app/install | bash -s -- --skip-shell
    logk
  else
    log "fnm already installed."
  fi

  if [ ! -d "${HOME}/.pyenv" ]; then
    log "Installing pyenv (Python version manager)..."
    curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash
    logk
    export PATH="$HOME/.pyenv/bin:$PATH" # AI: Add pyenv to PATH for current session
    # AI: Install pyenv-virtualenvwrapper plugin
    if [ -d "${HOME}/.pyenv/bin" ]; then # Check if pyenv installed correctly
        log "Installing pyenv-virtualenvwrapper plugin..."
        git clone https://github.com/pyenv/pyenv-virtualenvwrapper.git "$(${HOME}/.pyenv/bin/pyenv root)/plugins/pyenv-virtualenvwrapper" || warn "Failed to install pyenv-virtualenvwrapper"
        logk
    fi
    log "Installing Python 3.10.12 via pyenv..." # AI: Consistent with original script's pyenv version for Linux
    env PYTHON_CONFIGURE_OPTS="--enable-shared" "$HOME/.pyenv/bin/pyenv" install -s -f 3.10.12 # AI: Added -s for silent, -f for force
    "$HOME/.pyenv/bin/pyenv" global 3.10.12
    logk
  else
    log "pyenv already installed."
    export PATH="$HOME/.pyenv/bin:$PATH" # AI: Ensure pyenv is on PATH for current session
  fi
fi # End of Linux specific package installation

# ---------------------------------------------------------
# Install cargo, asdf (generic for all supported OS)
# ---------------------------------------------------------
# Install Rust/Cargo
if ! command_exists cargo; then
  log "Installing Rust and Cargo..."
  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs > rustup.sh
  sh rustup.sh -y -q --no-modify-path && rm rustup.sh
  # shellcheck source=/dev/null
  source "$HOME/.cargo/env" # Source for current session
  # Install Rust Apps
  # cargo install -q cargo-update # Example
  logk
else
  log "Rust/Cargo already installed."
fi

logn "Checking/Installing asdf (version manager)..."
if [ ! -d "$HOME/.asdf" ]; then
  log "Cloning asdf to ~/.asdf (branch v0.11.2)..."
  git clone --quiet https://github.com/asdf-vm/asdf.git ~/.asdf --branch v0.11.2
  logk
else
  log "asdf already installed in ~/.asdf."
  ( cd ~/.asdf && git fetch --quiet && git checkout --quiet v0.11.2 ) # AI: Ensure correct version
  logk
fi
# AI: Source asdf for current session to make it available for subsequent commands
# AI: This will be properly sourced by compat.bash/compat.sh later for new shells
if [ -f "$HOME/.asdf/asdf.sh" ]; then
    # shellcheck source=/dev/null
    . "$HOME/.asdf/asdf.sh"
fi


# ---------------------------------------------------------
# Setup compat files which will be used in .profile .bashrc .zshrc etc
# ---------------------------------------------------------
if [ "$CURRENT_OS" = "macos" ]; then
  log "Generating ~/compat.bash for macOS..."
  cat <<'EOF' >~/compat.bash
# ---------------------------------------------------------
# chezmoi managed - ~/.bashrc (macOS)
# ---------------------------------------------------------
# homebrew var setup
UNAME_MACHINE="$(/usr/bin/uname -m)"
if [[ $UNAME_MACHINE == "arm64" ]]; then
  HOMEBREW_PREFIX="/opt/homebrew"
else
  HOMEBREW_PREFIX="/usr/local"
fi
# AI: No HOMEBREW_REPOSITORY needed here if HOMEBREW_PREFIX is correctly set for brew shellenv

export PATH="$HOMEBREW_PREFIX/bin:$PATH"
export PATH="${HOME}/bin:${HOME}/.bin:${HOME}/.local/bin:$PATH"
# export PATH="/usr/local/cuda/bin:${PATH}" # AI: Example, uncomment if needed
# export LD_LIBRARY_PATH="/usr/local/cuda/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}" # AI: Example

# FZF (Bash)
[ -f ~/.fzf.bash ] && source ~/.fzf.bash

# Cargo
[ -f "$HOME/.cargo/env" ] && source "$HOME/.cargo/env"


######################################################################################
# pyenv
######################################################################################
export PYENV_ROOT="$HOME/.pyenv"
export PATH="${PYENV_ROOT}/bin:${PATH}" # AI: Simplified PATH, pyenv init adds shims

# Initialize Homebrew shell environment
if [ -x "$HOMEBREW_PREFIX/bin/brew" ]; then
    eval "$($HOMEBREW_PREFIX/bin/brew shellenv)"
fi

# Initialize pyenv
if command -v pyenv 1>/dev/null 2>&1; then
  eval "$(pyenv init --path)" # For shims
  eval "$(pyenv init -)"      # For shell integration (completion, etc.)
  # AI: pyenv-virtualenvwrapper integration
  if command -v pyenv virtualenvwrapper_lazy 1>/dev/null 2>&1; then
    pyenv virtualenvwrapper_lazy
  fi
fi
######################################################################################

# asdf (sourced after pyenv to ensure pyenv shims might be preferred if both manage python)
ASDF_DIR="${ASDF_DIR:-$HOME/.asdf}"
if [ -f "$ASDF_DIR/asdf.sh" ]; then
  # shellcheck source=/dev/null
  . "$ASDF_DIR/asdf.sh"
  # shellcheck source=/dev/null
  # . "$ASDF_DIR/completions/asdf.bash" # AI: asdf.sh should handle completions
fi

# fnm
export PATH="$HOME/.local/share/fnm:$PATH" # AI: fnm path might vary based on install
if command -v fnm 1>/dev/null 2>&1; then
  eval "$(fnm env --shell bash)"
fi
EOF
  logk

  log "Generating ~/compat.sh for macOS..."
  cat <<'EOF' >~/compat.sh
# ---------------------------------------------------------
# chezmoi managed - ~/.profile (macOS)
# ---------------------------------------------------------
# homebrew var setup
UNAME_MACHINE="$(/usr/bin/uname -m)"
if [ "$UNAME_MACHINE" = "arm64" ]; then
  HOMEBREW_PREFIX="/opt/homebrew"
else
  HOMEBREW_PREFIX="/usr/local"
fi

export PATH="$HOMEBREW_PREFIX/bin:$PATH"
export PATH="${HOME}/bin:${HOME}/.bin:${HOME}/.local/bin:$PATH"
# export PATH="/usr/local/cuda/bin:${PATH}" # AI: Example
# export LD_LIBRARY_PATH="/usr/local/cuda/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}" # AI: Example

# FZF (Shell agnostic if ~/.fzf.bash is POSIX compatible, otherwise Bash only)
if [ -f "$HOME/.fzf.bash" ]; then
  # shellcheck source=/dev/null
  source ~/.fzf.bash
fi

# Cargo
if [ -f "$HOME/.cargo/env" ]; then
  # shellcheck source=/dev/null
  . "$HOME/.cargo/env"
fi

######################################################################################
# pyenv
######################################################################################
export PYENV_ROOT="$HOME/.pyenv"
export PATH="${PYENV_ROOT}/bin:${PATH}"

# Initialize Homebrew shell environment
if [ -x "$HOMEBREW_PREFIX/bin/brew" ]; then
    eval "$($HOMEBREW_PREFIX/bin/brew shellenv)"
fi

# Initialize pyenv
if command -v pyenv 1>/dev/null 2>&1; then
  eval "$(pyenv init --path)"
  eval "$(pyenv init -)"
  if command -v pyenv virtualenvwrapper_lazy 1>/dev/null 2>&1; then
    pyenv virtualenvwrapper_lazy
  fi
fi
######################################################################################

# asdf
ASDF_DIR="${ASDF_DIR:-$HOME/.asdf}"
if [ -f "$ASDF_DIR/asdf.sh" ]; then
  # shellcheck source=/dev/null
  . "$ASDF_DIR/asdf.sh"
fi

# fnm
export PATH="$HOME/.local/share/fnm:$PATH" # AI: fnm path might vary
if command -v fnm 1>/dev/null 2>&1; then
  eval "$(fnm env --shell sh)" # AI: Use sh for .profile
fi
EOF
  logk
fi # End of macOS compat file generation

# ---------------------------------------------------------
# Linux compat files
# ---------------------------------------------------------
if [ "$CURRENT_OS" = "linux" ]; then
  log "Generating ~/compat.bash for Linux..."
  cat <<'EOF' >~/compat.bash
# ---------------------------------------------------------
# chezmoi managed - ~/.bashrc
# ---------------------------------------------------------
export PATH="${HOME}/bin:${HOME}/.bin:${HOME}/.local/bin:$PATH"
export PATH="/usr/local/cuda/bin:${PATH}"
export PATH="/usr/local/cuda-11.8/bin${PATH:+:${PATH}}"
export LD_LIBRARY_PATH="/usr/local/cuda-11.8/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}"


[ -f ~/.fzf.bash ] && . ~/.fzf.bash

. "$HOME/.cargo/env"

export PYENV_ROOT=~/.pyenv
export PATH="${PYENV_ROOT}/bin:${PYENV_ROOT}/shims:$PATH"

if [ -d "${HOME}/.pyenv" ]
then
        export PYENV_ROOT="${HOME}/.pyenv"
        export PATH="$PYENV_ROOT/bin:$PATH"
        eval "$($HOME/.pyenv/bin/pyenv init --path)"
        eval "$($HOME/.pyenv/bin/pyenv init -)"
        # $HOME/.pyenv/bin/pyenv virtualenvwrapper_lazy
fi

if [[ "$OSTYPE" == linux* ]]
then
    export ASDF_DIR="${HOME}/.asdf"
fi
. "$HOME/.asdf/asdf.sh"
. "$HOME/.asdf/lib/asdf.sh"
. "$HOME/.asdf/completions/asdf.bash"


# fnm
export PATH="$HOME/.local/share/fnm:$PATH"
eval "`fnm env`"

# ---------------------------------------------------------
# chezmoi managed - end
# ---------------------------------------------------------
EOF

  cat <<'EOF' >~/compat.sh
# ---------------------------------------------------------
# chezmoi managed - ~/.profile
# ---------------------------------------------------------
export PATH="${HOME}/bin:${HOME}/.bin:${HOME}/.local/bin:$PATH"
export PATH=/usr/local/cuda/bin:${PATH}
export PATH=/usr/local/cuda-11.8/bin${PATH:+:${PATH}}
export LD_LIBRARY_PATH=/usr/local/cuda-11.8/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}

[ -f ~/.fzf.bash ] && . ~/.fzf.bash

. "$HOME/.cargo/env"

export PYENV_ROOT="${HOME}/.pyenv"
export PATH="${PYENV_ROOT}/bin:${PYENV_ROOT}/shims:$PATH"

if [ -d "${HOME}/.pyenv" ]
then
        export PYENV_ROOT="${HOME}/.pyenv"
        export PATH="$PYENV_ROOT/bin:$PATH"
        eval "$($HOME/.pyenv/bin/pyenv init --path)"
        eval "$($HOME/.pyenv/bin/pyenv init -)"
        # $HOME/.pyenv/bin/pyenv virtualenvwrapper_lazy
fi

if [[ "$OSTYPE" == linux* ]]
then
    export ASDF_DIR="${HOME}/.asdf"
fi
. "$HOME/.asdf/asdf.sh"
. "$HOME/.asdf/lib/asdf.sh"
. "$HOME/.asdf/completions/asdf.bash"

# fnm
export PATH="$HOME/.local/share/fnm:$PATH"
eval "`fnm env`"

# sheldon version {{- .mySheldonVersion}}
# sheldon version {{ .mySheldonVersion}}

# ---------------------------------------------------------
# chezmoi managed - end
# ---------------------------------------------------------
EOF
  logk
fi # End of Linux compat file generation

add_helper_functions_to_shells
logk

logn "Sourcing compat.bash for current session to make tools available..."
# shellcheck source=/dev/null
source "${HOME}/compat.bash"
logk

# ---------------------------------------------------------
# OS-Specific Post-Setup
# ---------------------------------------------------------
if [ "$CURRENT_OS" = "macos" ]; then
  # Ensure fzf is set up (key bindings, completion)
  # Homebrew's fzf package often requires this.
  if command_exists brew && brew --prefix fzf >/dev/null 2>&1; then
    log "Setting up fzf shell integration (macOS/Homebrew)..."
    "$(brew --prefix fzf)/install" --all --no-update-rc # AI: --all for all shells, --no-update-rc as we handle sourcing
    logk
  fi

  # AI: pyenv Python installation for macOS
  if command_exists pyenv; then
    log "Installing Python 3.12.8 via pyenv for macOS..." # AI: Original script used 3.12.8 for macOS pyenv
    env PYTHON_CONFIGURE_OPTS="--enable-shared" pyenv install -s -f 3.12.8 # AI: Added -s for silent, -f for force
    pyenv global 3.12.8
    logk
  else
    warn "pyenv command not found, skipping macOS Python installation via pyenv."
  fi
fi

# Generic asdf check
if command_exists asdf; then
  logn "Current asdf versions:"
  asdf current || warn "asdf current failed. Check asdf plugins."
  logk
fi

logn 'fnm setup (Node.js)...'
if command_exists fnm; then
  eval "$(fnm env --use-on-cd)" # AI: Ensure fnm env is set for current shell
  FNM_NODE_VERSION="v20.11.0" # AI: Using a recent LTS version, adjust as needed. Original had v22.13.1
  log "Installing Node.js ${FNM_NODE_VERSION} via fnm..."
  fnm install "${FNM_NODE_VERSION}" || warn "fnm install ${FNM_NODE_VERSION} failed."
  fnm default "${FNM_NODE_VERSION}"
  logk
else
  warn "fnm command not found, skipping Node.js installation via fnm."
fi

# ---------------------------------------------------------
# Chezmoi
# ---------------------------------------------------------
log "Installing/Updating chezmoi..."
# AI: Install to $HOME/bin as per original script's intent, ensure $HOME/bin is on PATH
# AI: The script creates $HOME/bin earlier.
CHEZMOI_INSTALL_DIR="${HOME}/.local/bin" # AI: Changed to .local/bin as it's more standard for user binaries
mkdir -p "$CHEZMOI_INSTALL_DIR"
sh -c "$(curl -fsLS get.chezmoi.io)" -- -b "$CHEZMOI_INSTALL_DIR" -t v2.31.1 # AI: Using specific version from original
# Ensure chezmoi is executable and on PATH for current session
export PATH="$CHEZMOI_INSTALL_DIR:$PATH"
if ! command_exists chezmoi; then
    error "Chezmoi installation failed or not found in PATH."
else
    ok "Chezmoi installed/updated successfully."
fi
logk


ZSH_DOTFILES_PREP_SUCCESS="1"
log "-----------------------------------------------------------------------"
log "${COL_GREEN}All prerequisites installed successfully!${COL_RESET}"
log "You may need to restart your shell or source your ~/.bashrc, ~/.zshrc, or ~/.profile."
logn 'You should now be ready to run zsh-dotfiles. For example: chezmoi init --apply https://github.com/bossjones/zsh-dotfiles.git"'
logk
## ------------------------------------------------------
